# requirements.txt
PyYAML>=6.0

# test_validator.py - Basic test suite
import unittest
import json
import tempfile
import os
from pathlib import Path
from validator import AgentDataValidator, ValidationConfig, ErrorType


class TestAgentDataValidator(unittest.TestCase):
    
    def setUp(self):
        """Set up test fixtures."""
        self.validator = AgentDataValidator()
        
    def create_temp_file(self, data):
        """Create a temporary JSON file with test data."""
        temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False)
        json.dump(data, temp_file, indent=2)
        temp_file.close()
        return temp_file.name
    
    def test_valid_conversation(self):
        """Test validation of a properly formatted conversation."""
        valid_data = [
            {
                "turn_id": 1,
                "speaker": "user",
                "message": "Hello"
            },
            {
                "turn_id": 2,
                "speaker": "assistant", 
                "assistant_reply": "Hi there!"
            }
        ]
        
        temp_file = self.create_temp_file(valid_data)
        try:
            errors = self.validator.validate_file(temp_file)
            self.assertEqual(len(errors), 0, "Valid conversation should have no errors")
        finally:
            os.unlink(temp_file)
    
    def test_missing_turn_id(self):
        """Test detection of missing turn_id."""
        invalid_data = [
            {
                "speaker": "user",
                "message": "Hello"
            }
        ]
        
        temp_file = self.create_temp_file(invalid_data)
        try:
            errors = self.validator.validate_file(temp_file)
            self.assertEqual(len(errors), 1)
            self.assertEqual(errors[0].error_type, ErrorType.MISSING_REQUIRED_KEY)
            self.assertIn("turn_id", errors[0].message)
        finally:
            os.unlink(temp_file)
    
    def test_wrong_turn_id_sequence(self):
        """Test detection of incorrect turn_id sequence."""
        invalid_data = [
            {
                "turn_id": 1,
                "speaker": "user",
                "message": "Hello"
            },
            {
                "turn_id": 3,  # Should be 2
                "speaker": "assistant",
                "assistant_reply": "Hi!"
            }
        ]
        
        temp_file = self.create_temp_file(invalid_data)
        try:
            errors = self.validator.validate_file(temp_file)
            sequence_errors = [e for e in errors if e.error_type == ErrorType.TURN_ID_SEQUENCE]
            self.assertEqual(len(sequence_errors), 1)
            self.assertIn("Expected turn_id 2, got 3", sequence_errors[0].message)
        finally:
            os.unlink(temp_file)
    
    def test_invalid_speaker(self):
        """Test detection of invalid speaker values."""
        invalid_data = [
            {
                "turn_id": 1,
                "speaker": "robot",  # Invalid speaker
                "message": "Hello"
            }
        ]
        
        temp_file = self.create_temp_file(invalid_data)
        try:
            errors = self.validator.validate_file(temp_file)
            speaker_errors = [e for e in errors if e.error_type == ErrorType.INVALID_VALUE]
            self.assertTrue(any("Invalid speaker value" in e.message for e in speaker_errors))
        finally:
            os.unlink(temp_file)
    
    def test_assistant_missing_reply(self):
        """Test detection of missing assistant_reply for assistant turns."""
        invalid_data = [
            {
                "turn_id": 1,
                "speaker": "assistant"
                # Missing assistant_reply
            }
        ]
        
        temp_file = self.create_temp_file(invalid_data)
        try:
            errors = self.validator.validate_file(temp_file)
            reply_errors = [e for e in errors if "assistant_reply" in e.message]
            self.assertEqual(len(reply_errors), 1)
        finally:
            os.unlink(temp_file)
    
    def test_tool_validation(self):
        """Test tool usage validation."""
        invalid_data = [
            {
                "turn_id": 1,
                "speaker": "assistant",
                "assistant_reply": "Using a tool",
                "tool_used": "search",
                "tool_input": {"query": "test"}
                # Missing tool_output
            }
        ]
        
        temp_file = self.create_temp_file(invalid_data)
        try:
            errors = self.validator.validate_file(temp_file)
            tool_errors = [e for e in errors if e.error_type == ErrorType.TOOL_VALIDATION]
            self.assertTrue(len(tool_errors) >= 1)
            self.assertTrue(any("tool_output" in e.message for e in tool_errors))
        finally:
            os.unlink(temp_file)
    
    def test_tool_validation_complete(self):
        """Test valid tool usage."""
        valid_data = [
            {
                "turn_id": 1,
                "speaker": "assistant",
                "assistant_reply": "Using a tool",
                "tool_used": "search",
                "tool_input": {"query": "test"},
                "tool_output": {"results": ["result1", "result2"]}
            }
        ]
        
        temp_file = self.create_temp_file(valid_data)
        try:
            errors = self.validator.validate_file(temp_file)
            tool_errors = [e for e in errors if e.error_type == ErrorType.TOOL_VALIDATION]
            self.assertEqual(len(tool_errors), 0, "Complete tool usage should have no errors")
        finally:
            os.unlink(temp_file)
    
    def test_invalid_json_file(self):
        """Test handling of malformed JSON."""
        temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False)
        temp_file.write('{"invalid": json}')  # Invalid JSON
        temp_file.close()
        
        try:
            errors = self.validator.validate_file(temp_file.name)
            self.assertTrue(len(errors) >= 1)
            self.assertEqual(errors[0].error_type, ErrorType.JSON_PARSE)
        finally:
            os.unlink(temp_file.name)
    
    def test_nonexistent_file(self):
        """Test handling of non-existent files."""
        errors = self.validator.validate_file("nonexistent_file.json")
        self.assertEqual(len(errors), 1)
        self.assertEqual(errors[0].error_type, ErrorType.JSON_PARSE)
        self.assertIn("File not found", errors[0].message)
    
    def test_report_generation(self):
        """Test report generation in different formats."""
        # Create some errors for testing
        invalid_data = [{"turn_id": "invalid", "speaker": "user"}]
        temp_file = self.create_temp_file(invalid_data)
        
        try:
            errors = self.validator.validate_file(temp_file)
            
            # Test console report
            console_report = self.validator.generate_report("console")
            self.assertIn("validation error", console_report)
            self.assertIn("‚ùå", console_report)
            
            # Test markdown report
            markdown_report = self.validator.generate_report("markdown")
            self.assertIn("# Validation Report", markdown_report)
            self.assertIn("validation error", markdown_report)
            
        finally:
            os.unlink(temp_file)
    
    def test_custom_config(self):
        """Test validation with custom configuration."""
        config = ValidationConfig(
            valid_speakers=["user", "assistant", "system"],
            required_keys_user=["turn_id", "speaker", "message"]
        )
        validator = AgentDataValidator(config)
        
        # Test with system speaker (should be valid with custom config)
        data = [
            {
                "turn_id": 1,
                "speaker": "system",
                "message": "System message"
            }
        ]
        
        temp_file = self.create_temp_file(data)
        try:
            errors = validator.validate_file(temp_file)
            # Should have error for missing 'message' field in user turn
            speaker_errors = [e for e in errors if e.error_type == ErrorType.INVALID_VALUE and "speaker" in e.message]
            self.assertEqual(len(speaker_errors), 0, "System speaker should be valid with custom config")
        finally:
            os.unlink(temp_file)


class TestValidationConfig(unittest.TestCase):
    
    def test_default_config(self):
        """Test default configuration values."""
        config = ValidationConfig()
        self.assertIn("turn_id", config.required_keys_user)
        self.assertIn("speaker", config.required_keys_user)
        self.assertIn("assistant_reply", config.required_keys_assistant)
        self.assertEqual(config.valid_speakers, ["user", "assistant"])
    
    def test_yaml_config_loading(self):
        """Test loading configuration from YAML file."""
        config_data = {
            "valid_speakers": ["user", "assistant", "system"],
            "required_keys_user": ["turn_id", "speaker", "content"],
            "optional_keys": ["metadata", "timestamp"]
        }
        
        # Create temporary YAML file
        temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False)
        import yaml
        yaml.dump(config_data, temp_file)
        temp_file.close()
        
        try:
            config = ValidationConfig.from_yaml(temp_file.name)
            self.assertEqual(config.valid_speakers, ["user", "assistant", "system"])
            self.assertIn("content", config.required_keys_user)
            self.assertIn("metadata", config.optional_keys)
        finally:
            os.unlink(temp_file.name)


if __name__ == "__main__":
    unittest.main()